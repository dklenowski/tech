Categories: linux
Tags: packet
      processing
      ip


## Linux Packet Processing

### `netstat -i`

- Contains actual (before firewall processing) packet values.

        [root@titan ipv4]# netstat -i
        Kernel Interface table
        Iface   MTU Met    RX-OK RX-ERR RX-DRP RX-OVR    TX-OK TX-ERR TX-DRP TX-OVR Flg
        eth0   1500   0     5690      0      0      0     4671     21      0      9 BRU
        lo     3924   0       42      0      0      0       42      0      0      0 LRU

### `netstat -s`

- Contains values after firewall processing.
- This values are generated by the corresponding signal handler for the protocol.

        root@titan ipv4]# netstat -s
        Ip:
            5749 total packets received
            0 forwarded
            0 incoming packets discarded
            45 incoming packets delivered
            4738 requests sent out

### Packet Processing

#### 1. Data Link Layer

##### 1.a NIC card receives a packet and puts on its RX ring

- Performs FCS check etc.
- Writes all statistics to a #include netdevicestats struct.
- Since this is at the DLL, all related stats are written before intercepted by firewall.
- e.g. 

        struct netdevicestats {
        unsigned long rxpackets; /* total packets received */
        unsigned long txpackets; /* total packets transmitted /
        unsigned long rx_bytes; / total bytes received /
        unsigned long tx_bytes; / total bytes transmitted /
        unsigned long rx_errors; / bad packets received */
        ….

##### 1.b Generates an interrupt and moves the packet into an `skbuff` (`linux/skbuff.h`) structure

#### 2. Network Layer

- For IP packets, the ethernet interrupt handler calls the IP handler.
- It examines the IP header from

        struct iphdr {
            #if defined(__LITTLE_ENDIAN_BITFIELD)
                     __u8    ihl:4,
                        version:4;
            #elif defined (__BIG_ENDIAN_BITFIELD)
                    __u8    version:4,
                       ihl:4;
            #else
            #error  "Please fix <asm/byteorder.h>"
            #endif
                __u8    tos;
                __u16   tot_len;
                __u16   id;
                __u16   frag_off;
                __u8    ttl;
                __u8    protocol;
                __u16   check;
                __u32   saddr;
                __u32   daddr;
                /*The options start here. */
        };

- The actual ip handler is net/ipv4/ip_input.c, which defines a structure

        struct ip_mib ip_statistics={2,IPDEFTTL,};      /* Forwarding=No, Default TTL=64 */

Defined in the `net/snmp.h` as

        struct ip_mib
        {
                unsigned long   IpForwarding;
                unsigned long   IpDefaultTTL;
                unsigned long   IpInReceives;
                unsigned long   IpInHdrErrors;
                unsigned long   IpInAddrErrors;
                unsigned long   IpForwDatagrams;
                unsigned long   IpInUnknownProtos;
                unsigned long   IpInDiscards;
                unsigned long   IpInDelivers;
                unsigned long   IpOutRequests;
                unsigned long   IpOutDiscards;
                unsigned long   IpOutNoRoutes;
                unsigned long   IpReasmTimeout;
                unsigned long   IpReasmReqds;
                unsigned long   IpReasmOKs;
                unsigned long   IpReasmFails;
                unsigned long   IpFragOKs;
                unsigned long   IpFragFails;
                unsigned long   IpFragCreates;
        };

- Note (defined in `ip_input.c` comments)

  - RFC1122: 3.1.2.2 MUST silently discard any IP frame that fails the checksum.
  - Is the datagram acceptable?
    - Length at least the size of an ip header
    - Version of 4
    - Checksums correctly. [Speed optimisation for later, skip loopback checksums]
    - Doesn’t have a bogus length