<!--
Categories:
  - java
Tags:
  - java
  - jni
  - java native
-->

## Java Native Interface

- Part of the JDK.
- Allows Java code that runs within a Java Virtual Machine to operate with applications / libraries written in other languages (e.g. C, C++).
- Also an invocation API allows you to embed the JVM into your native applications.
- e.g.
  - Native method can create java objects (e.g. arrays / strings) and then inspect and use these objects to perform a task.
  - Native method can create / use objects created by Java application code.
  - Native method can update Java objects that it created or were passed to it.
  - Native methods can call Java methods.
  - Can catch and throw exceptions from the native method and have those exceptions handled in the Java application.
- e.g.

          C Side                          Java Side
                         _________
          Functions --- |         | --- Exceptions
                        |         |
          Libraries --- |  JNI    | --- Classes
                        |         |
                        |_________| --- VM

## Process ##

Notes:

- Try to avoid underscores in native methods/java classes (as java header files are auto generated).

### 1. Create the Java class file ###

- Write the java class file that declares the native method.
- When declaring native methods:
  - Must declare all methods (java or native) within a class file on the java side.
  - Native methods  Must include the keyword `native` as part of the methods definition.
  - e.g.

          public native void [method-name]

  - The native method declaration in the java class provides only the method signature for the method and no implementation.
  - Native methods can be called in the same way a regular method is called.
- e.g.

            class helloWorld  {
              public native void displayHelloWorld();
              static {
                  // System.loadLibrary("libhello");
                  // temporary fix : cant change java library path
                  System.load("/tmp/jniTest/libhello.so");
              }
              public static void main(String[] args) {
                  new helloWorld().displayHelloWorld();
              }
            }

- Compile using the following command:

          bash# javac helloWorld.java

### 2. Create the Java header file ###

- Use the `javah` command to generate a header file for the native method, with the native interface flag (`-jni`).
- i.e. to obtain the formal signature for the native method.
- The implementation of the native function (in the header file) accepts 2 parameters even though, in its definition on the Java side, accepts no parameters (JNI requires every native method to have these 2 parameters).
  - `JNIEnv`
      - Interface pointer.
      - Used so native code can access parameters and objects passed to it from the Java application.
  - `jobject`
      - References the current object itself (analogy "this" variable in Java).
- The name of the native method function that implements the native method consists of

        prefix + packageName + "_" + fullyQualifiedClassname + "_" + methodName

- e.g.

        Java_helloWorld_displayHelloWorld

- e.g.

          # javah helloWorld

          # ls -la
          total 36
          drwxr-xr-x    2 root     root         4096 Mar 17 18:29 .
          drwxrwxrwt   13 root     root         4096 Mar 17 18:28 ..
          -rw-r--r--    1 root     root          474 Mar 17 18:26 helloWorld.class
          -rw-r--r--    1 root     root          401 Mar 17 18:04 helloWorld.h
          -rw-r--r--    1 root     root          357 Mar 17 18:26 helloWorld.java
          
          # cat helloWorld.h
          /* DO NOT EDIT THIS FILE - it is machine generated */
          #include <jni.h>
          /* Header for class helloWorld */
          
          #ifndef _Included_helloWorld
          #define _Included_helloWorld
          #ifdef __cplusplus
          extern "C" {
          #endif
          /*
           * Class:     helloWorld
           * Method:    displayHelloWorld
           * Signature: ()V
           */
          JNIEXPORT void JNICALL Java_helloWorld_displayHelloWorld
            (JNIEnv *, jobject);
          
          #ifdef __cplusplus
          }
          #endif
          #endif

### 3. Create the native method

- For existing C / C++ functions, ensure that the native method signature matches the signature generated on the Java side.
-  Must always include `jni.h` as it provides information for the native language code requires to interact with the Java runtime system.


          /*  ---- helloWorldImp.c ----  */
          #include <jni.h>
          #include "helloWorld.h"
          #include <stdio.h>
          
          JNIEXPORT void JNICALL
          Java_helloWorld_displayHelloWorld(JNIEnv *env, jobject obj) {
            printf("Hello world");
            return;
          }

### Create the shared library ###

- Create the shared library that will be used in Java.

          # gcc -fPIC -DPIC -shared -W -I/usr/java/j2sdk1.5.0/include/ -I/usr /java/j2sdk1.5.0/include/linux/ helloWorldImp.c -o libhello.so

- where:

          -fPIC and -DPIC     Generate position independent code (i.e. code suitable for 
                              dynamic linking).
          -shared             gcc builds a shared library.
          -I<include_file>    For the location of jni.h and jni_md.h
          -W                  Linker option to set the version number of the library that 
                              linking programs will load at run time.

- Ensure the library has correct permissions:

          # chmod 0755 libhello.so

- Update the shared library path (e.g. `/etc/ld.so.conf` or `LD_LIBRARY_PATH`)

### Run the program ###

          # java helloWorld
    